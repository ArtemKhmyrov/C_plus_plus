#include<iostream>//библиотека для потока ввода-вывода
#include<ctime>//библиотека для рандомныйх чисел 
#include <stdio.h>//библиотека для не помню чего 
using namespace std;//директива

void heap(int *A, int j, int M=7 )//оператор войд
{
	
	int mx = j;//приравниваем джитый элемент к максимальному
		while (true)//цикл пока выполнять
		{
			if (2*j + 1 < M)//условие если
			{
				if (A[2*j + 1] > A[mx])//условие если левый ребенок больше максимального
				{
					mx = 2*j + 1;//Для левых ветвей
				}
			}
			if (2 * j + 2 < M)//условие если
			{
				if (A[2 * j + 2] > A[mx])//условие если правый ребенок больше максимально 
				{
					mx = 2 * j + 2;//для правых детей
				}
			}
			if (mx == j)//приравниваем к джитому элементу
				break;//завершение
			else//условие иначе
			{
				swap(A[mx], A[j]);//свапаем местами
				j = mx;//приравниваем к максимульному элементу
			}
		}
	

}
void heapsort(int *A, int M = 7)//оператор войд
{
	for (int i = M / 2; i >= 0; i--)//цикл для строк
		heap(A, i, M);//вставить
	for (int i = M - 1; i >= 1; i--)//цикл для строк
	{
		swap(A[0], A[i]);//свапаем местами
		heap(A, 0, i);//вывести
	}
}
int main()//оператор
{

	setlocale(LC_ALL, "RUS");//использование русской клавиатуры
	srand(unsigned(time(NULL)));//для рандомных чисел
	int N = 7, M = 7;//матрица 7 на 7
	int ** A = new int *[N];//выделение памяти
	for (int i = 0; i < N; i++)//строчка
		A[i] = new int[M];//выделение памяти

	for (int i = 0; i < N; i++)//заполняем строчку
		for (int j = 0; j < M; j++)//заполняем столбец
			A[i][j] = ((rand() % 9));//рандомная матрица не более 9 чисел



	cout << "Вот Ваша матрица:" << endl << endl;//вывод
	for (int i = 0; i < N; i++)//строчка
	{
		for (int j = 0; j < M; j++)//столбец
			cout << A[i][j] << " ";//вывод
		cout << endl;//отступ
	}

	cout << endl;//отступ

	int R, c, C;//переменная
	cout << "Сортировка Пузырьком - 1;\nСортировка Кучей(Пирамидальная) - 2;\nСортировка Шелла с шагом 2 - 3.\n " << endl;//вывод
	cout << "Введите номер сортировки: " << endl;//вывод
	cout << endl;//отступ
	cout << " Ваш ответ: ";//вывод
	cout << endl;//отступ
	cin >> R;//ввод
	c = R;//переменная для перезапуска программы
	cout << endl;//отступ


	do//оператор
	{
		R = c;//приравниваем к новой переменной
		switch (R)//оператор
		{


		case 1://кейс 
		{
			cout << " 'Сортировка пузырьком' " << endl;//вывод
			cout << endl;//отступ


						 //  сортировка до побочной диагонали включительно


			for (int i = 0; i < N; ++i)//цикл для строки
			{
				int *FSort = new int[N];//выделение памяти для диагонали
				int x = 0;//счетчик для определения строки 
				int y = i;//отвечает за номер элемента в строке
				while (y >= 0)//цикл ваил пока не джошли до последнего элемента в диагонали
				{
					FSort[x] = A[x][y];//копируем
					x++;//переходим на строку + 1
					y--;//переходим на следующий элемент - 1
				}
				for (int f = 0; f < x-1; f++)//Работает со всеми элементами в данной строке
				{
					for (int j = f; j < x - 1; ++j)//столбцы
					{
						if (FSort[j] < FSort[j + 1])//условие если 1 элемент меньше второго
						{
							C = FSort[j];//приравниваем
							FSort[j] = FSort[j + 1];//заменяем
							FSort[j + 1] = C; //заменяем

						}
					}

				}
				x = 0;//строка 
				y = i;//элемент в строке
				while (y >= 0)//цикл ваил пока не джошли до последнего элемента в диагонали
				{
					A[x][y] = FSort[x];//вставляем в диагональ
					x++;//переходим на следующую строчку + 1
					y--;//переходим к следующему элементу - 1
				}

			}


			//сортировка после побочной диагонали


			for (int i = 0; i < N; ++i)//цикл для строки
			{
				int *FSort = new int[N];//выделение памяти для диагонали
				int x = i;//счетчик для определения элемента в строке
				int y = 0;//отвечает за строку
				while (x < N)//цикл ваил пока не джошли до последнего элемента в диагонали
				{
					FSort[y] = A[x][N - y - 1];//копируем
					x++;//переходим на элемент + 1
					y++;//переходим на следующиую строку
				}

				for (int f = 0; f < y-1; f++)//Работает со всеми элементами в данной строке
				{
					for (int j = f; j < y-1; ++j)//столбцы
					{
						if (FSort[j] < FSort[j + 1])//условие если 1 элемент меньше второго
						{
							C = FSort[j];//приравниваем
							FSort[j] = FSort[j + 1];//заменяем
							FSort[j + 1] = C; //заменяем

						}
					}

				}
				x = i;//отвечает за элемент в строке
				y = 0;//за строку
				while (x < N)//цикл ваил пока не джошли до последнего элемента в диагонали
				{
					A[x][N - y - 1] = FSort[y];//вставляем в диагональ
					x++;//переходим к следующему элементу + 1
					y++;//переходим к следующей строчке + 1
				}

			}

			cout << "Новый массив: " << endl;//вывод
			cout << endl;//отступ

			for (int i = 0; i < N; ++i)//строки
			{
				for (int k = 0; k < M; ++k)//столбцы
					cout << A[i][k] << " ";//вывод
				cout << endl;//отступ
			}
		}
		break;//закрытие кейса


		case 2://кейс 2
		{
			cout << " 'Сортировка пирамидальная' " << endl;//вывод
			cout << endl;//отступ

			
			int *B = new int[N];//новыq vfccbd 
			

			for (int j = 0; j < M; j++)//цикл для столбцов
			{
				for (int i = 0; i < N; i++)//цикл для строк
					B[i] = A[i][j];//приравниваем новый массив к старому 
				heapsort(B,N);//вызываем функцию описанную в самом верху 
			for (int i = 0; i < N; i++)//цикл для строк
				A[i][j] = B[i];//обратно заменяем матрицы 
			}

				for (int i = 0; i < N; i++, cout << endl) // строки
				{
					for (int j = 0; j < N; j++)//столбы
					{
						cout << A[i][j] << " ";//вывод
					}
				}
		}
		break;//закрытие кейса

		case 3://кейс 3
		{
			cout << " 'Сортировка Шелла' " << endl; //вывод
			cout << endl;//отступ

			int step = N / 2; // определяем шаг
			while (step > 0)//цикл пока шаг больше 0 выполнять
			{
				for (int i = 0; i < N - step; i++)//строчки
					for (int k = 0; k < N; k++)//столбцы
					{
						{
							int j = i;//приравниваем 
							if (k % 2 != 0)//условие если
							{
								while (j >= 0 && A[j][k] > A[j + step][k])// если столбец нечётный, то сортируем по возрастанию
								{
									swap(A[j][k], A[j + step][k]);//меняем местами элементы
									j -= step;//уменьшаем шаг
								}
							}
							else while (j >= 0 && A[j][k] < A[j + step][k])// если столбец чётный, то сортируем по убыванию
							{
								swap(A[j][k], A[j + step][k]);//меняем элементы местами
								j -= step;//уменьшаем шаг
							}
						}
					}
				step /= 2; // переходим к следующему шагу
			}
			for (int i = 0; i < N; i++, cout << endl) // строки
				for (int j = 0; j < N; j++)//столбы
					cout << A[i][j] << " ";//вывод

		}
		break;//закрытие кейса

		}

		cout << endl;//отступ
		cout << "Вы хотите перезапустить программу?" << endl;//вывод
		cout << "Да - Введите номер сортировки: / Нет, нажмите - 4" << endl;//вывод
		cout << "Ваш ответ: ";//вывод
		cin >> c; // ввод
	} while (c != 4); // проверка условия на перезапуск
	cout << endl;//отступ 


	system("pause");//задержка консоли
	return 0;//задержка консоли
}





